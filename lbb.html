<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>送给丽宝宝的网站</title>
</head>
<style>
  #aaaa {
    height: 100vh;
    width: 100vw;
    position: fixed;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    z-index: 9999;
    background: linear-gradient(135deg, #ff9a9e, #fad0c4);
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #aaaa span {
    display: inline-block;
    border-radius: 4px;
    height: 34px;
    margin-top: 27px;
    width: 80px;
    background: #f05159;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #music1 {
    display: none;
  }
  #mohao {
    height: 100vh;
    width: 100vw;
    background-image: url("https://img2.imgtp.com/2024/03/09/sbIfzgSQ.jpg");
    background-size: cover;
    background-position: center center;
    background-repeat: no-repeat;
    background-attachment: fixed;
  }
  body {
    background: linear-gradient(135deg, #ff9a9e, #fad0c4);
    margin: 0;
    overflow: hidden;
    background-repeat: no-repeat;
  }

  .text-gradient {
    position: fixed;
    text-align: center;
    width: 218px;
  }

  .a {
    left: 50%;
    top: 50%;
    margin-left: -109px;
    margin-top: -107px;
    font-size: 18px;
  }

  /* 
  .b {
    left: 50%;
    top: 50%;
    margin-left: -60px;
    margin-top: -12px;
    font-size: 12px;
  }

  .c {
    left: 50%;
    top: 50%;
    margin-left: -60px;
    margin-top: 23px;
    font-size: 12px;
  } */

  .text-gradient[data-text]::after {
    content: attr(data-text);
    /* color: cyan; */
    color: #ffbebe;
    position: absolute;
    top: 0;
    left: 0;
    /* mask-image: linear-gradient(to left, red, rgba(0, 0, 0, .5));
    -webkit-mask-image: linear-gradient(to left, red, rgba(0, 0, 0, .5)); */
  }
</style>

<body>
  <div id="aaaa" onclick="start()">
    <span>进入</span>
  </div>
  <div id="mohao">
    <h1 class="text-gradient a"
      data-text="丽宝宝你今天辛苦啦,如果觉得累了我随时在,我会永远陪着你。我喜欢看你笑的样子，你每次笑的都很甜。所以我希望你累的时候知道有我在，能会心一笑。加油丽宝宝ヾ(◍°∇°◍)ﾉﾞ">
      丽宝宝你今天辛苦啦,如果觉得累了我随时在,我会永远陪着你。我喜欢看你笑的样子，你每次笑的都很甜。所以我希望你累的时候知道有我在，能会心一笑。加油丽宝宝ヾ(◍°∇°◍)ﾉﾞ</h1>
    <!-- <h1 class="text-gradient b" data-text="虽然我可能帮不了你什么">虽然我可能帮不了你什么</h1>
    <h1 class="text-gradient c" data-text="但我会永远陪着你">但我会永远陪着你</h1> -->
    <!-- <canvas id="canvas" width="390" height="844"></canvas> -->
    <!-- <audio src="./ninxia.mp3" loop="loop" controls="controls" autoplay="autoplay"></audio> -->
    <audio id="music1" controls="controls" preload autoplay="autoplay" loop="loop">
      <source src="https://m10.music.126.net/20240309220831/9114d6591a9c311a1edefd350511d1ab/ymusic/8897/c0d5/6084/7a31fe7e0c06ce62bac311dda327b3c4.mp3" type="audio/mpeg" />
    </audio>
  </div>
  <script>

    function start() {
      var aaaa = document.getElementById('aaaa');
      aaaa.style.display = 'none'
      var audio = document.getElementById('music1');
      audio.play();
    }



//     var canvas = document.getElementById("canvas");

//     canvas.width = window.innerWidth;
//     canvas.height = window.innerHeight;

//     var gl = canvas.getContext('webgl');
//     if (!gl) {
//       console.error("Unable to initialize WebGL.");
//     }

//     var time = 0.0;


//     var vertexSource = `
// attribute vec2 position;
// void main() {
// 	gl_Position = vec4(position, 0.0, 1.0);
// }
// `;

//     var fragmentSource = `
// precision highp float;

// uniform float width;
// uniform float height;
// vec2 resolution = vec2(width, height);

// uniform float time;

// #define POINT_COUNT 8

// vec2 points[POINT_COUNT];
// const float speed = -0.5;
// const float len = 0.25;
// float intensity = 1.3;
// float radius = 0.008;


// float sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    
// 	vec2 a = B - A;
// 	vec2 b = A - 2.0*B + C;
// 	vec2 c = a * 2.0;
// 	vec2 d = A - pos;

// 	float kk = 1.0 / dot(b,b);
// 	float kx = kk * dot(a,b);
// 	float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;
// 	float kz = kk * dot(d,a);      

// 	float res = 0.0;

// 	float p = ky - kx*kx;
// 	float p3 = p*p*p;
// 	float q = kx*(2.0*kx*kx - 3.0*ky) + kz;
// 	float h = q*q + 4.0*p3;

// 	if(h >= 0.0){ 
// 		h = sqrt(h);
// 		vec2 x = (vec2(h, -h) - q) / 2.0;
// 		vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
// 		float t = uv.x + uv.y - kx;
// 		t = clamp( t, 0.0, 1.0 );

		
// 		vec2 qos = d + (c + b*t)*t;
// 		res = length(qos);
// 	}else{
// 		float z = sqrt(-p);
// 		float v = acos( q/(p*z*2.0) ) / 3.0;
// 		float m = cos(v);
// 		float n = sin(v)*1.732050808;
// 		vec3 t = vec3(m + m, -n - m, n - m) * z - kx;
// 		t = clamp( t, 0.0, 1.0 );

	
// 		vec2 qos = d + (c + b*t.x)*t.x;
// 		float dis = dot(qos,qos);
        
// 		res = dis;

// 		qos = d + (c + b*t.y)*t.y;
// 		dis = dot(qos,qos);
// 		res = min(res,dis);
		
// 		qos = d + (c + b*t.z)*t.z;
// 		dis = dot(qos,qos);
// 		res = min(res,dis);

// 		res = sqrt( res );
// 	}
    
// 	return res;
// }



// vec2 getHeartPosition(float t){
// 	return vec2(16.0 * sin(t) * sin(t) * sin(t),
// 			-(13.0 * cos(t) - 5.0 * cos(2.0*t)
// 			- 2.0 * cos(3.0*t) - cos(4.0*t)));
// }


// float getGlow(float dist, float radius, float intensity){
// 	return pow(radius/dist, intensity);
// }

// float getSegment(float t, vec2 pos, float offset, float scale){
// 	for(int i = 0; i < POINT_COUNT; i++){
// 		points[i] = getHeartPosition(offset + float(i)*len + fract(speed * t) * 6.28);
// 	}
    
// 	vec2 c = (points[0] + points[1]) / 2.0;
// 	vec2 c_prev;
// 	float dist = 10000.0;
    
// 	for(int i = 0; i < POINT_COUNT-1; i++){
// 		c_prev = c;
// 		c = (points[i] + points[i+1]) / 2.0;
// 		dist = min(dist, sdBezier(pos, scale * c_prev, scale * points[i], scale * c));
// 	}
// 	return max(0.0, dist);
// }

// void main(){
// 	vec2 uv = gl_FragCoord.xy/resolution.xy;
// 	float widthHeightRatio = resolution.x/resolution.y;
// 	vec2 centre = vec2(0.5, 0.5);
// 	vec2 pos = centre - uv;
// 	pos.y /= widthHeightRatio;
// 	pos.y += 0.02;
// 	float scale = 0.000015 * height;
	
// 	float t = time;
    
//   float dist = getSegment(t, pos, 0.0, scale);
//   float glow = getGlow(dist, radius, intensity);
  
//   vec3 col = vec3(0.0);

//   col += 10.0*vec3(smoothstep(0.003, 0.001, dist));
//   //Pink glow
//   col += glow * vec3(1.0,0.05,0.3);
  

//   dist = getSegment(t, pos, 3.4, scale);
//   glow = getGlow(dist, radius, intensity);
  

//   col += 10.0*vec3(smoothstep(0.003, 0.001, dist));
//   //Blue glow
//   col += glow * vec3(0.1,0.4,1.0);
        

// 	col = 1.0 - exp(-col);


// 	col = pow(col, vec3(0.4545));


//  	gl_FragColor = vec4(col,1.0);
// }
// `;



//     window.addEventListener('resize', onWindowResize, false);

//     function onWindowResize() {
//       canvas.width = window.innerWidth;
//       canvas.height = window.innerHeight;
//       gl.viewport(0, 0, canvas.width, canvas.height);
//       gl.uniform1f(widthHandle, window.innerWidth);
//       gl.uniform1f(heightHandle, window.innerHeight);
//     }


//     function compileShader(shaderSource, shaderType) {
//       var shader = gl.createShader(shaderType);
//       gl.shaderSource(shader, shaderSource);
//       gl.compileShader(shader);
//       if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
//         throw "Shader compile failed with: " + gl.getShaderInfoLog(shader);
//       }
//       return shader;
//     }


//     function getAttribLocation(program, name) {
//       var attributeLocation = gl.getAttribLocation(program, name);
//       if (attributeLocation === -1) {
//         throw 'Cannot find attribute ' + name + '.';
//       }
//       return attributeLocation;
//     }

//     function getUniformLocation(program, name) {
//       var attributeLocation = gl.getUniformLocation(program, name);
//       if (attributeLocation === -1) {
//         throw 'Cannot find uniform ' + name + '.';
//       }
//       return attributeLocation;
//     }


//     var vertexShader = compileShader(vertexSource, gl.VERTEX_SHADER);
//     var fragmentShader = compileShader(fragmentSource, gl.FRAGMENT_SHADER);


//     var program = gl.createProgram();
//     gl.attachShader(program, vertexShader);
//     gl.attachShader(program, fragmentShader);
//     gl.linkProgram(program);

//     gl.useProgram(program);


//     var vertexData = new Float32Array([
//       -1.0, 1.0, 	// top left
//       -1.0, -1.0, 	// bottom left
//       1.0, 1.0, 	// top right
//       1.0, -1.0, 	// bottom right
//     ]);


//     var vertexDataBuffer = gl.createBuffer();
//     gl.bindBuffer(gl.ARRAY_BUFFER, vertexDataBuffer);
//     gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);


//     var positionHandle = getAttribLocation(program, 'position');

//     gl.enableVertexAttribArray(positionHandle);
//     gl.vertexAttribPointer(positionHandle,
//       2,
//       gl.FLOAT,
//       false,
//       2 * 4,
//       0
//     );


//     var timeHandle = getUniformLocation(program, 'time');
//     var widthHandle = getUniformLocation(program, 'width');
//     var heightHandle = getUniformLocation(program, 'height');

//     gl.uniform1f(widthHandle, window.innerWidth);
//     gl.uniform1f(heightHandle, window.innerHeight);

//     var lastFrame = Date.now();
//     var thisFrame;

//     function draw() {

//       thisFrame = Date.now();
//       time += (thisFrame - lastFrame) / 1000;
//       lastFrame = thisFrame;

//       gl.uniform1f(timeHandle, time);

//       gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

//       requestAnimationFrame(draw);
//     }

//     draw();
  </script>
</body>

</html>